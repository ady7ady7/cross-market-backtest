"""
Base strategy class and strategy result tracking.

Supports multi-timeframe strategies and composable strategy patterns.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Dict, Optional, List, Any, Set
from datetime import datetime, time
import pandas as pd

from .position import PositionSide, PositionConfig


@dataclass
class StrategySignal:
    """
    Signal generated by a strategy.
    """
    timestamp: datetime
    side: PositionSide
    confidence: float = 1.0  # 0-1 confidence score
    metadata: Dict[str, Any] = None  # Additional signal information

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


@dataclass
class StrategyResult:
    """
    Results from a strategy execution.
    """
    strategy_name: str
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    total_pnl: float = 0.0
    win_rate: float = 0.0
    avg_win: float = 0.0
    avg_loss: float = 0.0
    avg_trade: float = 0.0
    max_win: float = 0.0
    max_loss: float = 0.0
    profit_factor: float = 0.0
    avg_r_multiple: float = 0.0

    def calculate_metrics(self, trades: List[Any]):
        """Calculate strategy metrics from trade list"""
        if not trades:
            return

        self.total_trades = len(trades)

        wins = [t.realized_pnl for t in trades if t.realized_pnl > 0]
        losses = [t.realized_pnl for t in trades if t.realized_pnl < 0]

        self.winning_trades = len(wins)
        self.losing_trades = len(losses)
        self.total_pnl = sum(t.realized_pnl for t in trades)

        if self.total_trades > 0:
            self.win_rate = (self.winning_trades / self.total_trades) * 100

        if wins:
            self.avg_win = sum(wins) / len(wins)
            self.max_win = max(wins)

        if losses:
            self.avg_loss = sum(losses) / len(losses)
            self.max_loss = min(losses)

        if self.total_trades > 0:
            self.avg_trade = self.total_pnl / self.total_trades

        # Profit factor
        total_wins = sum(wins) if wins else 0
        total_losses = abs(sum(losses)) if losses else 0
        if total_losses > 0:
            self.profit_factor = total_wins / total_losses

        # Average R-multiple
        r_multiples = [t.r_multiple for t in trades if t.r_multiple != 0]
        if r_multiples:
            self.avg_r_multiple = sum(r_multiples) / len(r_multiples)


class BaseStrategy(ABC):
    """
    Base class for all trading strategies.

    Subclass this to create custom strategies. Strategies can use multiple
    timeframes and can be combined with other strategies.
    """

    def __init__(self, name: str, timeframes: List[str], config: Dict[str, Any] = None):
        """
        Initialize strategy.

        Args:
            name: Strategy name
            timeframes: List of timeframes this strategy uses (e.g., ['1m', '5m', '1h'])
            config: Strategy-specific configuration
        """
        self.name = name
        self.timeframes = timeframes
        self.config = config or {}
        self.position_config = self._create_position_config()

        # Time and day filters
        self.allowed_days: Optional[Set[str]] = None  # Day names: 'Monday', 'Tuesday', etc.
        self.allowed_time_start: Optional[time] = None
        self.allowed_time_end: Optional[time] = None
        self._configure_time_filters()

    @abstractmethod
    def generate_signals(self, data: pd.DataFrame, timestamp: datetime) -> Optional[StrategySignal]:
        """
        Generate trading signals based on current market data.

        Args:
            data: DataFrame with aligned multi-timeframe data
            timestamp: Current timestamp

        Returns:
            StrategySignal or None if no signal
        """
        pass

    @abstractmethod
    def should_exit(self, position: Any, data: pd.DataFrame, timestamp: datetime) -> bool:
        """
        Check if position should be exited based on strategy-specific conditions.

        Args:
            position: Current position
            data: Current market data
            timestamp: Current timestamp

        Returns:
            True if position should be closed
        """
        pass

    def _create_position_config(self) -> PositionConfig:
        """
        Create position configuration from strategy config.

        Override this to customize position management per strategy.
        """
        return PositionConfig(
            risk_percent=self.config.get('risk_percent', 1.0),
            sl_type=self.config.get('sl_type', 'percent'),
            sl_percent=self.config.get('sl_percent', 1.0),
            sl_time_bars=self.config.get('sl_time_bars'),
            tp_type=self.config.get('tp_type', 'rr'),
            tp_percent=self.config.get('tp_percent'),
            tp_rr_ratio=self.config.get('tp_rr_ratio', 2.0),
            partial_exits=self.config.get('partial_exits', [])
        )

    def _configure_time_filters(self):
        """Configure time and day filters from config."""
        # Parse allowed days (e.g., ['Monday', 'Friday'])
        if 'allowed_days' in self.config:
            self.allowed_days = set(self.config['allowed_days'])

        # Parse time range (e.g., '10:00-18:00')
        if 'allowed_time_range' in self.config:
            time_range = self.config['allowed_time_range']
            if time_range and '-' in time_range:
                start_str, end_str = time_range.split('-')
                try:
                    start_parts = [int(x) for x in start_str.strip().split(':')]
                    end_parts = [int(x) for x in end_str.strip().split(':')]
                    self.allowed_time_start = time(start_parts[0], start_parts[1] if len(start_parts) > 1 else 0)
                    self.allowed_time_end = time(end_parts[0], end_parts[1] if len(end_parts) > 1 else 0)
                except (ValueError, IndexError):
                    pass  # Invalid format, ignore

    def is_trading_time_allowed(self, data: pd.DataFrame, timestamp: datetime) -> bool:
        """
        Check if current timestamp is within allowed trading times.
        Uses existing day_of_week column from dataset.

        Args:
            data: DataFrame with market data (includes day_of_week column)
            timestamp: Current timestamp to check

        Returns:
            True if trading is allowed at this time, False otherwise
        """
        # Check day of week using existing day_of_week column from data
        if self.allowed_days is not None:
            current_row = data[data['timestamp'] == timestamp]
            if not current_row.empty:
                day_name = current_row.iloc[0].get('day_of_week')
                if day_name and day_name not in self.allowed_days:
                    return False

        # Check time of day
        if self.allowed_time_start is not None and self.allowed_time_end is not None:
            current_time = timestamp.time()
            if not (self.allowed_time_start <= current_time <= self.allowed_time_end):
                return False

        return True

    def get_indicator_values(self, data: pd.DataFrame, timestamp: datetime,
                            timeframe: str = None) -> Dict[str, float]:
        """
        Helper to extract indicator values for current timestamp.

        Args:
            data: DataFrame with data
            timestamp: Current timestamp
            timeframe: Specific timeframe (if multi-timeframe)

        Returns:
            Dictionary of indicator values
        """
        row = data[data['timestamp'] == timestamp]
        if row.empty:
            return {}

        row = row.iloc[0]
        values = {}

        # Extract values based on timeframe prefix if specified
        if timeframe:
            prefix = f"{timeframe}_"
            for col in data.columns:
                if col.startswith(prefix):
                    key = col.replace(prefix, '')
                    values[key] = row[col]
        else:
            # Extract all non-timestamp columns
            for col in data.columns:
                if col != 'timestamp':
                    values[col] = row[col]

        return values


class MultiStrategyComposer:
    """
    Composes multiple strategies to work together.

    Manages signal aggregation and position allocation across strategies.
    """

    def __init__(self, strategies: List[BaseStrategy], allocation_method: str = 'equal'):
        """
        Initialize multi-strategy composer.

        Args:
            strategies: List of strategy instances
            allocation_method: How to allocate capital ('equal', 'weighted', 'priority')
        """
        self.strategies = strategies
        self.allocation_method = allocation_method

        # Validate that all strategies have unique names
        names = [s.name for s in strategies]
        if len(names) != len(set(names)):
            raise ValueError("All strategies must have unique names")

    def get_all_timeframes(self) -> List[str]:
        """Get all unique timeframes required by all strategies"""
        all_timeframes = set()
        for strategy in self.strategies:
            all_timeframes.update(strategy.timeframes)
        return sorted(list(all_timeframes))

    def generate_all_signals(self, data: pd.DataFrame, timestamp: datetime) -> Dict[str, StrategySignal]:
        """
        Generate signals from all strategies.

        Args:
            data: Aligned multi-timeframe data
            timestamp: Current timestamp

        Returns:
            Dictionary mapping strategy name to signal
        """
        signals = {}
        for strategy in self.strategies:
            # Check if trading is allowed at this time for this strategy
            if not strategy.is_trading_time_allowed(data, timestamp):
                continue

            signal = strategy.generate_signals(data, timestamp)
            if signal:
                signals[strategy.name] = signal

        return signals

    def check_exits(self, positions: Dict[str, Any], data: pd.DataFrame,
                   timestamp: datetime) -> List[str]:
        """
        Check all strategies for exit signals.

        Args:
            positions: Dictionary of positions by strategy name
            data: Current market data
            timestamp: Current timestamp

        Returns:
            List of strategy names that should exit
        """
        exits = []
        for strategy in self.strategies:
            if strategy.name in positions:
                if strategy.should_exit(positions[strategy.name], data, timestamp):
                    exits.append(strategy.name)

        return exits